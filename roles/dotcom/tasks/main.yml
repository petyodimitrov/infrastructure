- name: create app dirs
  tags: [dotcom_backup, dotcom_restore]
  file:
    dest: "{{ web_volume_path }}/{{ item }}"
    state: directory
  with_items:
    - legacy
    - uploads
    - db

- name: checkout app
  tags: dotcom_restore
  register: app_version
  git:
    accept_hostkey: yes
    dest: "{{ web_volume_path }}/dotcom"
    force: yes
    update: yes
    repo: "{{ dotcom_app_repository }}"

- name: find current app git sha
  register: app_name
  tags: dotcom_backup
  shell: >
    echo "dotcom.$(git rev-parse --short HEAD)-$(date +%Y%m%d.%H%M%S)"
  args:
    chdir: "{{ web_volume_path }}/dotcom"

- name: ensure app image exists
  shell: >
    docker pull {{ dotcom_app_image }}

- name: ensure backup image exists
  shell: >
    docker pull {{ dotcom_backup_image }}

- name: restore backup
  tags: dotcom_restore
  when: dotcom_backup_to_restore
  shell: >
    docker run --rm --tty
    --name {{ dotcom_backup_to_restore }}-restore
    --volume {{ web_volume_path }}:/restore:rw
    --log-driver syslog --log-opt tag={{ dotcom_backup_to_restore }}-restore --log-opt syslog-address={{ papertrail_log_destination }}
    {{ dotcom_backup_image }}
    sh -c "AWS_ACCESS_KEY_ID={{ dotcom_backup_aws_access_key_id }} AWS_SECRET_ACCESS_KEY={{ dotcom_backup_aws_secret_access_key }} gof3r cp s3://{{ dotcom_backup_s3_bucket }}/{{ dotcom_backup_to_restore }} /restore/{{ dotcom_backup_to_restore }} --endpoint {{ dotcom_backup_aws_region }}"

- name: build app
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-deps
    --volume {{ web_volume_path }}/dotcom:/app:rw
    --workdir /app
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-deps --log-opt syslog-address={{ papertrail_log_destination }}
    --env MIX_ENV=prod
    {{ dotcom_app_image }}
    ./script/deps_install --only prod

- name: ensure app assets image exists
  shell: >
    docker pull {{ dotcom_assets_image }}

- name: compile assets
  when: app_version is changed or dotcom_force_deploy
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-assets
    --volume {{ web_volume_path }}/dotcom:/app:rw
    --workdir /app
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-assets --log-opt syslog-address={{ papertrail_log_destination }}
    --env MIX_ENV=prod
    {{ dotcom_assets_image }}
    ./script/assets_compile

- name: digest assets
  when: app_version is changed or dotcom_force_deploy
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-assets
    --volume {{ web_volume_path }}/dotcom:/app:rw
    --workdir /app
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-assets --log-opt syslog-address={{ papertrail_log_destination }}
    --env MIX_ENV=prod
    {{ dotcom_app_image }}
    ./script/assets_digest

- name: migrate db
  when: app_version is changed or dotcom_force_deploy
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-db
    --volume {{ web_volume_path }}/dotcom:/app:rw
    --net {{ nginx_net }}
    --workdir /app
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-db --log-opt syslog-address={{ papertrail_log_destination }}
    --env MIX_ENV=prod
    --env DB_URL=ecto://{{ postgres_admin_user }}:{{ postgres_admin_pass }}@postgres.{{ postgres_net }}/changelog
    {{ dotcom_app_image }}
    ./script/db_migrate

- name: deploy latest app version
  shell: >
    docker run --detach --tty
    --restart unless-stopped
    --label fqdn={{ fqdn }}
    --name {{ app_name.stdout }}
    --net {{ nginx_net }}
    --net-alias dotcom
    --volume {{ web_volume_path }}/dotcom:/app:rw
    --volume {{ web_volume_path }}/uploads:/uploads:rw
    --workdir /app
    --log-driver syslog --log-opt tag={{ app_name.stdout }} --log-opt syslog-address={{ papertrail_log_destination }}
    --env MIX_ENV=prod
    --env PORT=4000
    --env DB_URL=ecto://{{ postgres_admin_user }}:{{ postgres_admin_pass }}@postgres.{{ postgres_net }}/changelog
    --env CM_SMTP_TOKEN={{ campaign_monitor_smtp_token }}
    --env CM_API_TOKEN={{ campaign_monitor_api_token }}
    --env AWS_ACCESS_KEY_ID={{ aws_access_key_id }}
    --env AWS_SECRET_ACCESS_KEY={{ aws_secret_access_key }}
    --env GITHUB_CLIENT_ID={{ github_client_id }}
    --env GITHUB_CLIENT_SECRET={{ github_client_secret }}
    --env GITHUB_API_TOKEN={{ github_api_token }}
    --env TWITTER_CONSUMER_KEY={{ twitter_consumer_key }}
    --env TWITTER_CONSUMER_SECRET={{ twitter_consumer_secret }}
    --env SLACK_INVITE_API_TOKEN={{ slack_invite_api_token }}
    --env SLACK_APP_API_TOKEN={{ slack_app_api_token }}
    --env SECRET_KEY_BASE={{ secret_key_base }}
    --env SIGNING_SALT={{ signing_salt }}
    --env ROLLBAR_ACCESS_TOKEN={{ rollbar_access_token }}
    --env BUFFER_TOKEN={{ buffer_token }}
    {{ dotcom_app_image }}
    ./script/run

- name: do not continue until the latest app version responds to HTTP requests
  delay: 5
  register: latest_app_version_response
  retries: 10
  shell: >
    docker run --rm
    --net {{nginx_net }}
    {{ dotcom_app_image }}
    curl --silent --connect-timeout 1 --output /dev/null http://{{ app_name.stdout }}:4000
  until: latest_app_version_response is success

- name: configure nginx site HTTP/S common config
  template:
    src: changelog.com.common.j2
    dest: "{{ nginx_config_dir }}/sites/{{ fqdn }}.common"

- name: configure nginx site
  template:
    src: changelog.com.j2
    dest: "{{ nginx_config_dir }}/sites/{{ fqdn }}.site"

- name: reload nginx so that it resolves the new app host
  shell: >
    docker exec nginx.{{ nginx_net }} nginx -t &&
    docker kill -s HUP nginx.{{ nginx_net }}

- name: find all app instances older than the last one
  register: venerable_apps
  shell: >
    docker ps -q --filter label=fqdn={{ fqdn }} | tail -n +2

- name: cleanup app instances older than the last one
  ignore_errors: true
  shell: >
    docker stop {{ venerable_apps.stdout_lines | join(" ") }} ;
    docker rm -f {{ venerable_apps.stdout_lines | join(" ") }}

- name: reload nginx so that it removes all venerable app hosts
  shell: >
    docker exec nginx.{{ nginx_net }} nginx -t &&
    docker kill -s HUP nginx.{{ nginx_net }}

- name: notify rollbar of deployment
  when: app_version is changed or dotcom_force_deploy
  shell: >
    curl https://api.rollbar.com/api/1/deploy/ -F access_token={{ rollbar_access_token }} -F environment=production -F revision={{ app_version['after'] }}

- name: backup db
  tags: dotcom_backup
  when: dotcom_backup
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-db-backup
    --net {{ postgres_net }}
    --volume {{ web_volume_path }}/db:/db:rw
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-db-backup --log-opt syslog-address={{ papertrail_log_destination }}
    --env PGHOST=postgres.{{ postgres_net }}
    --env PGPORT=5432
    --env PGUSER={{ postgres_admin_user }}
    --env PGPASSWORD={{ postgres_admin_pass }}
    --env PGDATABASE=changelog
    postgres
    sh -c "pg_dump --no-owner --no-privileges --clean --if-exists --verbose --file /db/{{ app_name.stdout }}.sql"

- name: backup to S3
  tags: dotcom_backup
  when: dotcom_backup
  shell: >
    docker run --rm --tty
    --name {{ app_name.stdout }}-backup
    --volume {{ web_volume_path }}/uploads:/uploads:ro
    --volume {{ web_volume_path }}/legacy:/legacy:ro
    --volume {{ web_volume_path }}/db:/db:ro
    --volume {{ web_volume_path }}/dotcom/_build/prod:/github.com/dotcom/_build/prod:ro
    --log-driver syslog --log-opt tag={{ app_name.stdout }}-backup --log-opt syslog-address={{ papertrail_log_destination }}
    {{ dotcom_backup_image }}
    sh -c "tar -cf - uploads legacy db github.com | AWS_ACCESS_KEY_ID={{ dotcom_backup_aws_access_key_id }} AWS_SECRET_ACCESS_KEY={{ dotcom_backup_aws_secret_access_key }} gof3r put -b {{ dotcom_backup_s3_bucket }} -k {{ app_name.stdout }}.tar --endpoint {{ dotcom_backup_aws_region }}"

- name: clean db backup dir
  tags: dotcom_backup
  file:
    path: "{{ web_volume_path }}/db"
    state: absent
